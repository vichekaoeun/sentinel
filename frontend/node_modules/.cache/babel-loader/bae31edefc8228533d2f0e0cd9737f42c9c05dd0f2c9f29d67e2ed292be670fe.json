{"ast":null,"code":"class WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.connected = false;\n    this.subscriptions = new Map();\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000;\n  }\n  connect(onConnect, onError) {\n    try {\n      // Use native WebSocket instead of SockJS/STOMP\n      this.ws = new WebSocket('ws://localhost:8080/ws');\n      this.ws.onopen = () => {\n        console.log('Connected to WebSocket');\n        this.connected = true;\n        this.reconnectAttempts = 0;\n        if (onConnect) onConnect();\n      };\n      this.ws.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          this.handleMessage(data);\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n        }\n      };\n      this.ws.onclose = () => {\n        console.log('WebSocket connection closed');\n        this.connected = false;\n        this.attemptReconnect(onConnect, onError);\n      };\n      this.ws.onerror = error => {\n        console.error('WebSocket error:', error);\n        this.connected = false;\n        if (onError) onError(error);\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n      if (onError) onError(error);\n    }\n  }\n  handleMessage(data) {\n    // Handle different message types\n    if (data.type === 'alert') {\n      const callback = this.subscriptions.get('/topic/alerts');\n      if (callback) callback(data.payload);\n    } else if (data.type === 'position') {\n      const callback = this.subscriptions.get('/topic/positions');\n      if (callback) callback(data.payload);\n    } else if (data.type === 'trade') {\n      const callback = this.subscriptions.get('/topic/trades');\n      if (callback) callback(data.payload);\n    }\n  }\n  attemptReconnect(onConnect, onError) {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\n      setTimeout(() => {\n        this.connect(onConnect, onError);\n      }, this.reconnectDelay * this.reconnectAttempts);\n    } else {\n      console.error('Max reconnection attempts reached');\n    }\n  }\n  subscribe(destination, callback) {\n    if (!this.connected) {\n      console.warn('WebSocket not connected');\n      return null;\n    }\n    this.subscriptions.set(destination, callback);\n    return {\n      destination,\n      callback\n    };\n  }\n  unsubscribe(destination) {\n    this.subscriptions.delete(destination);\n  }\n  send(destination, message) {\n    if (this.connected && this.ws) {\n      const payload = {\n        destination,\n        payload: message\n      };\n      this.ws.send(JSON.stringify(payload));\n    } else {\n      console.warn('WebSocket not connected, cannot send message');\n    }\n  }\n  disconnect() {\n    if (this.ws) {\n      this.ws.close();\n      this.connected = false;\n      this.subscriptions.clear();\n      this.reconnectAttempts = 0;\n    }\n  }\n  isConnected() {\n    return this.connected;\n  }\n}\nexport default new WebSocketService();","map":{"version":3,"names":["WebSocketService","constructor","ws","connected","subscriptions","Map","reconnectAttempts","maxReconnectAttempts","reconnectDelay","connect","onConnect","onError","WebSocket","onopen","console","log","onmessage","event","data","JSON","parse","handleMessage","error","onclose","attemptReconnect","onerror","type","callback","get","payload","setTimeout","subscribe","destination","warn","set","unsubscribe","delete","send","message","stringify","disconnect","close","clear","isConnected"],"sources":["/Users/vichekaoeun/Projects/sentinel/sentinel/frontend/src/services/websocketService.js"],"sourcesContent":["class WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.connected = false;\n    this.subscriptions = new Map();\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000;\n  }\n\n  connect(onConnect, onError) {\n    try {\n      // Use native WebSocket instead of SockJS/STOMP\n      this.ws = new WebSocket('ws://localhost:8080/ws');\n      \n      this.ws.onopen = () => {\n        console.log('Connected to WebSocket');\n        this.connected = true;\n        this.reconnectAttempts = 0;\n        if (onConnect) onConnect();\n      };\n\n      this.ws.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          this.handleMessage(data);\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n        }\n      };\n\n      this.ws.onclose = () => {\n        console.log('WebSocket connection closed');\n        this.connected = false;\n        this.attemptReconnect(onConnect, onError);\n      };\n\n      this.ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n        this.connected = false;\n        if (onError) onError(error);\n      };\n\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n      if (onError) onError(error);\n    }\n  }\n\n  handleMessage(data) {\n    // Handle different message types\n    if (data.type === 'alert') {\n      const callback = this.subscriptions.get('/topic/alerts');\n      if (callback) callback(data.payload);\n    } else if (data.type === 'position') {\n      const callback = this.subscriptions.get('/topic/positions');\n      if (callback) callback(data.payload);\n    } else if (data.type === 'trade') {\n      const callback = this.subscriptions.get('/topic/trades');\n      if (callback) callback(data.payload);\n    }\n  }\n\n  attemptReconnect(onConnect, onError) {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\n      \n      setTimeout(() => {\n        this.connect(onConnect, onError);\n      }, this.reconnectDelay * this.reconnectAttempts);\n    } else {\n      console.error('Max reconnection attempts reached');\n    }\n  }\n\n  subscribe(destination, callback) {\n    if (!this.connected) {\n      console.warn('WebSocket not connected');\n      return null;\n    }\n\n    this.subscriptions.set(destination, callback);\n    return { destination, callback };\n  }\n\n  unsubscribe(destination) {\n    this.subscriptions.delete(destination);\n  }\n\n  send(destination, message) {\n    if (this.connected && this.ws) {\n      const payload = {\n        destination,\n        payload: message\n      };\n      this.ws.send(JSON.stringify(payload));\n    } else {\n      console.warn('WebSocket not connected, cannot send message');\n    }\n  }\n\n  disconnect() {\n    if (this.ws) {\n      this.ws.close();\n      this.connected = false;\n      this.subscriptions.clear();\n      this.reconnectAttempts = 0;\n    }\n  }\n\n  isConnected() {\n    return this.connected;\n  }\n}\n\nexport default new WebSocketService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}